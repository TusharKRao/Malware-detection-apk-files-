import csv
import random
import math


def splitDataset(dataset, splitRatio):
	trainSize = int(len(dataset) * splitRatio)
	train = []
	test = list(dataset)

	while len(train) < trainSize:
		index = len(test)-1
		train.append(test.pop(index))
	# print train, test
	return [train, test]


def separateByClass(dataset):
	separated = {}
	for i in range(len(dataset)):
		vector = dataset[i]
		if (vector[-1] not in separated):
			separated[vector[-1]] = []
		separated[vector[-1]].append(vector)
	return separated


def summarize(dataset):

	summaries = []
	for y in zip(*dataset):
		mean = sum(y)/float(len(y))
		std = math.sqrt(sum([pow(x-mean,2) for x in y])/float(len(y)-1))
		# print mean, std
		summaries.append((mean, std))

	del summaries[-1]
	return summaries


def summarizeByClass(dataset):
	separated = separateByClass(dataset)
	summaries = {}
	for classValue, instances in separated.iteritems():
		summaries[classValue] = summarize(instances)
	return summaries


def calc_prob(summaries, inputVector):
	probabilities = {}
	for classValue, classSummaries in summaries.iteritems():
		probabilities[classValue] = 1
		for i in range(len(classSummaries)):
			mean, stdev = classSummaries[i]
			x = inputVector[i]
			if stdev == 0:
				probabilities[classValue] = 0
			else:
				e = math.exp(-(math.pow(x-mean,2)/(2*math.pow(stdev,2))))
				probabilities[classValue] *= e * (1 / (math.sqrt(2*math.pi) * stdev))
	return probabilities


def predict(summaries, inputVector):
	probabilities = calc_prob(summaries, inputVector)
	bestLabel, bestProb = None, -1
	for classValue, probability in probabilities.iteritems():
		if bestLabel is None or probability > bestProb:
			bestProb = probability
			bestLabel = classValue
	return bestLabel


def getPredictions(summaries, testSet):
	predictions = []
	for i in range(len(testSet)):
		result = predict(summaries, testSet[i])
		predictions.append(result)
	return predictions


def getAccuracy(testSet, predictions):
	correct = 0
	for i in range(len(testSet)):
		if testSet[i][-1] == predictions[i]:
			correct += 1
	return (correct/float(len(testSet))) * 100.0



import numpy as np
import math
import csv
import random

def __init__(self, x, y, splitratio):
	self.input = x
	self.target = y
	self.splitratio = splitratio
	self.seperated = {}
	self.test = []
	self.train = []


def divide_test_and_train(self):
	for i in range(int(len(self.input) * self.splitratio)):
		self.train.append(list([self.input[i], self.target[i]]))
	for i in range(len(self.train), len(self.input)):
		self.test.append(list([self.input[i], self.target[i]]))

def split_into_class(self):
	for x, y in self.train:
		if y not in self.seperated:
			self.seperated[y] = []
		self.seperated[y].append(x)

def compute_probs(self, input_data):
	# iterate through classes
	prob = {0:1.0, 1:1.0}
	for key in self.seperated.keys():
		prob[key] = float(len(self.seperated[key]) / (len(self.input) - len(self.seperated[key])))
			# iterate through collumns
		for i in range(len(self.input[0])):
			y = self.input[:,i]
			numbers = y
			mean = sum(numbers / len(numbers))
			variance = sum([pow(x - mean, 2) for x in numbers]) / float(len(numbers) - 1)
			if variance == 0:
				continue
			std = math.sqrt(variance)
			# print std
				for x in input_data:
				exp = math.exp(-(math.pow(x - mean, 2) / (2 * math.pow(std, 2))))
				# print x, exp
				prob[key] *= (1 / (math.sqrt(2 * math.pi) * std)) * exp
				# print prob[key]
		
	# print prob
	return max(prob, key=prob.get)

def predict_all(self):
	correct = 0
	for x in self.test:
		# print self.compute_probs(x[0])
		if self.compute_probs(x[0]) == x[1]:
			correct += 1
	accuracy = float(correct) / len(self.input)
	return accuracy
