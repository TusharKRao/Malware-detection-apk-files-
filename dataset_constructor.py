from xml.dom.minidom import parseString
import xlsxwriter , csv
import sys , string
import re , operator
import glob , os


## to run this code use the following syntax
#
#  python dataset_constructor.py /home/tushar/Documents/IAS/apkfiles/ <name of the file you want to generate>

path_list = list()
app_permissions = list()
rank_dictionary = {}
all_perm = list()
occurences = list()
rank_selection_ratio = 0.7
number_apps = 0
feature_vector = list()
f_vector = list()


command_line_variable = sys.argv[1]
#print sys.argv[1]
#print command_line_variable
	
def union(list_a,list_b):
	return list(set(list_a) | set(list_b))


#Obtaining the list of all .apk files
def obtainPaths(directory_name):
	path_list_temp = os.listdir(directory_name)
	for path in path_list_temp:
		temp = directory_name + path + '/AndroidManifest.txt'
		path_list.append(temp)	
	number_apps = len(path_list)
	#print number_apps



#obtaining all the permissions of an apk(run multiple times)
def obtainAppPermissions(path):
	app_perm = list()
	#this was the arsing technique used when we had manifest.xml files to parse
	"""with open(path,'r') as f:
		data = f.read()
	dom = parseString(data)
	nodes = dom.getElementsByTagName('uses-permission')"""

	with open(path,'r') as f:
		app_perm = f.readlines()
	#remove whitespace characters like `\n` at the end of each line
	app_perm = [x.strip() for x in app_perm] 

	# Iterate over all the uses-permission nodes
	"""for node in nodes: 
	  #print node.toxml()
	  perm =  node.getAttribute('android:name') 
	  perm = str(perm)
	  #print type(perm)
	  app_perm.append(perm)
	#print app_permissions
	f.close()"""
	return app_perm

#iteratively constructs the complete feature dictionary() run alongside obtainAppPermissions()
def createListsForDictionary(path_list):
	perm_builder = list()
	for path in path_list :
		app_permissions = obtainAppPermissions(path)
		perm_builder = union(app_permissions,perm_builder)
	#print perm_builder
	#print len(perm_builder)
	return perm_builder

#perm_builder has all the permissions used in the dataset of apk files built into it

def generate_occurences(all_perm, path_list):
	occur = [0] * len(all_perm)
	for path in path_list:
		app_permissions = obtainAppPermissions(path)
		for perm in app_permissions:
			for i in range(len(all_perm)):
				if(perm == all_perm[i]):
					occur[i] += 1
	#print occur
	return occur

#pairwise dict constructor used to link the corresponding lists
def createDictionary(all_perm):
	dictionary = {}
	dictionary = dict(zip(all_perm,occurences))
	dictionary = sorted(dictionary.items(), key=operator.itemgetter(1), reverse = True)
	#print dictionary
	return dictionary


#module  to select the features based on a ranking algorithm
#returns number of top features to be handled
def selectRankBased(rank_dictionary):
	total_selected = rank_selection_ratio * len(rank_dictionary)
	total_selected = int(total_selected)
	#current ranking algorithm to be used is the generic ranking algo where top rank_selection_ratio% permmissions(features) chosen
	return total_selected


def featureVectorConstructor(path):
	app_permissions = obtainAppPermissions(path)
	#print app_permissions
	#now app_permissions has the list of all permissions related to the app
	feature_vector = [-1] * (len(all_perm))
	#The applications permissions are in app_permissions list
	#print app_permissions
	#HERE YOU CAN USE THE VALUE RETURNED BY selectRankBased(dictionary) TO SELECT ONLY THE TOP RATIO OF THE VALUES
	for i in range(len(all_perm) - 2):#####try changing 2 to 1 and check output
		flag = 0
		for j in range(len(app_permissions)):
			if(all_perm[i] == app_permissions[j]):
				feature_vector[i] = 1
				flag = 1
		if(flag == 0):
			feature_vector[i] = -1
	#print path

	##determining class labels
	comparator = str(path)
	comparator = comparator.replace(comparator[:36], '')
	#debugginng done comparator is what we want
	#print comparator
	if(comparator[0] == 'm'):
		feature_vector[len(all_perm) - 1] = -1
	else:
		feature_vector[len(all_perm) - 1] = 1
	#feature_vector[len(all_perm)] = 1
	#print feature_vector
	#print len(feature_vector)
	return feature_vector


def createDataSet(all_perm,path_list):
	with open(sys.argv[2] , "w") as f:
		writer = csv.writer(f)
		all_perm.append("CLASS_LABEL")
		for  perm in all_perm:
			f.write(perm + ',')
		f.write("\n")           #the first line is written into the csv file here
		for k in range(len(path_list)):
			f_vector = featureVectorConstructor(path_list[k])
			#print f_vector feature vector seems to be working fine
			#print f_vector
			for i in range(len(f_vector)):
				f.write(str(f_vector[i]) + ',')
			f.write("\n")
	f.close()


	##cant use xlsheet as it was giving out of bounds error for some reason
	"""workbook = xlsxwriter.Workbook("Android_Dataset.xlsx")
	worksheet = workbook.add_worksheet()
	#all_perm.append("CLASS_LABEL")
	for i in range(len(all_perm)):
		worksheet.write(0 , i , all_perm[i])
	##add rows and manipulate  the spreadsheet here
	# feed featureVectorConstructor the path for each apk iteratively
	for k in range(len(path_list)):
		f_vector = featureVectorConstructor(path_list[k])
		for j in range(len(f_vector)):
			worksheet.write(k+1 , j , f_vector[j])"""
	#all feature vectors of manifest.xml files in the path_list have been added to ALL_PERMISSIONS.xlsx

#def main():
obtainPaths(command_line_variable)
#DEBUGGING DONE!obtainAppPermissions(path_list[4])
all_perm = createListsForDictionary(path_list)
#print len(all_perm)

    	#this works::writer.writerow([perm,])
    #writer.writerows(all_new2)


occurences = generate_occurences(all_perm,path_list)
#print occurences
rank_dictionary = createDictionary(all_perm)
#f = featureVectorConstructor(path_list[0])
createDataSet(all_perm,path_list)


"""with open("Android_Dataset.txt" , "r") as f:
	reader = csv.reader(f)
	data = list(reader)
	#for datum in data:
	#	print datum
	#print data[2]"""

######################################################################################
#ALL COMMENTED LINES USED FOR TESTING REMOVE THE HASHES AND TRY RUNNING THEM TO UNDERSTAND CODE BETTER



###this next variable holds the top permissions to be chosen after ranking is done
#top_rank = selectRankBased(rank_dictionary)
#featureVectorConstructor(path_list[0])
#print all_perm
#createDataSet(all_perm,path_list)
######################################################################################



#if __name__ == "__main__": main()


#this code was within the else statement of the createlistfordirctionary module
"""	print len(all_perm) * len(app_permissions)
				for i in range(len(all_perm)):
					if all_perm[i] == perm :
						occurences[i] += 1
					else:
						temp_list.append(perm)
						print temp_list
						occurences.append(1)"""
